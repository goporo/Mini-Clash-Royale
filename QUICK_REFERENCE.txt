// ═══════════════════════════════════════════════════════════════════
// QUICK REFERENCE: Client-Server Communication
// ═══════════════════════════════════════════════════════════════════

// ─────────────────────────────────────────────────────────────────
// SERVER → CLIENT (Broadcast every 50ms)
// ─────────────────────────────────────────────────────────────────

// Message: "entity-update"
// Payload: EntityUpdateDto[]
{
  id: 1,
  x: 4.5,
  y: 2.3,
  hp: 80,
  maxHp: 100,
  type: "knight",
  team: 0,
  isAlive: true
}

// Unity Handler:
// NetworkClient.OnEntityUpdate(EntityUpdateDto[] entities)
// ↓
// EntityViewManager.GetOrCreateView()
// ↓
// EntityView.SetTargetPosition()
// EntityView.SetHealth()

// ─────────────────────────────────────────────────────────────────
// CLIENT → SERVER (On player action)
// ─────────────────────────────────────────────────────────────────

// Message: "spawn-unit"
// C# Code:
NetworkClient.Instance.Room.Send("spawn-unit", new
{
  x = 4.0f,
  y = -1.0f,
  unitType = "knight"
});

// Server Handler:
// ClashRoom.handleSpawnUnit(client, message)
// ↓
// director.spawnEntity(type, x, y, team)

// ─────────────────────────────────────────────────────────────────
// UNITY UPDATE LOOP (Client)
// ─────────────────────────────────────────────────────────────────

void Update()
{
  float dt = Time.deltaTime;
  
  // 1. Update visuals (smooth interpolation)
  EntityViewManager.Instance.UpdateVisuals(dt);
  
  // 2. Handle input
  if (Input.GetKeyDown(KeyCode.Space))
    SendSpawnCommandToServer(spawnPosition);
  
  // 3. Update UI
  // UIController.UpdateUI(dt);
}

// ❌ NO director.Tick()
// ❌ NO ai.Tick()
// ❌ NO matchEnd.Tick()

// ─────────────────────────────────────────────────────────────────
// SERVER SIMULATION LOOP
// ─────────────────────────────────────────────────────────────────

onSimulationTick(dt: number) {
  // 1. Update all gameplay
  this.director.update(dt);
  
  // 2. Update AI
  this.ai.update(dt, this.director);
  
  // 3. Check win conditions
  this.matchEnd.update(this.director);
  
  // 4. Broadcast to all clients
  this.broadcastGameState();
}

// Runs at: 20 ticks/sec (50ms interval)

// ─────────────────────────────────────────────────────────────────
// COMMON COMMANDS TO ADD
// ─────────────────────────────────────────────────────────────────

// Unity → Server Commands:

// 1. Spawn Unit
Room.Send("spawn-unit", { x, y, unitType });

// 2. Play Spell
Room.Send("play-spell", { x, y, spellType });

// 3. Surrender
Room.Send("surrender", {});

// 4. Emote
Room.Send("emote", { emoteId });

// ─────────────────────────────────────────────────────────────────
// DEBUGGING
// ─────────────────────────────────────────────────────────────────

// Server Logs:
[Server] ClashRoom created!
[Server] Client abc123 joined!
[Server] Spawned knight (id=1) at (4, -1)
[Server] Entity 5 (knight) died
[Server] Match Over! Team1 Wins!

// Unity Logs:
[Network] Joined or created room: room123
[Network] Entity update received: 12 entities
[Client] Sent spawn command to server at (4, 0, -1)

// ─────────────────────────────────────────────────────────────────
// FILE STRUCTURE
// ─────────────────────────────────────────────────────────────────

// Unity (Client):
NetworkClient.cs          → Connection & message handlers
EntityViewManager.cs      → Manages all views
EntityView.cs             → Individual entity visual
EntityUpdateDto.cs        → Server message format
GameplayBootstrap.cs      → Main game loop (visuals only)

// Server:
ClashRoom.ts              → Main room class
GameplayDirector          → Entity simulation
AIController              → AI spawning
MatchEndDetector          → Win conditions

// ─────────────────────────────────────────────────────────────────
// PERFORMANCE TIPS
// ─────────────────────────────────────────────────────────────────

// Server:
✅ Run at fixed 20 ticks/sec
✅ Only broadcast changed entities (optimization)
✅ Use entity pooling for spawns
✅ Spatial hashing for targeting

// Client:
✅ Smooth interpolation (10x smoothingSpeed)
✅ Object pooling for views
✅ LOD for distant entities
✅ Batch updates in single frame

// ═══════════════════════════════════════════════════════════════════
// END OF QUICK REFERENCE
// ═══════════════════════════════════════════════════════════════════
